/*
 * gfx.c - Implementação da biblioteca gráfica GFX (COMPLETA)
 * Contém renderização de texto e primitivas.
 */

#include "gfx.h"
#include "ST7789.h" // Precisa das funções st7789_
#include <stdlib.h> // Para abs()

// --- Funções de Ajuda (Helpers) ---
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }

// --- Variáveis de Estado (Texto) ---
static int16_t cursor_x = 0;
static int16_t cursor_y = 0;
static uint16_t text_color = ST77XX_WHITE;
static uint8_t text_size = 1;

// --- Fonte GLCD (COMPLETA - NÃO MODIFIQUE) ---
static const unsigned char glcdfont[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, // 0x20 ' '
    0x00, 0x00, 0x5F, 0x00, 0x00, // 0x21 '!'
    0x00, 0x07, 0x00, 0x07, 0x00, // 0x22 '"'
    0x14, 0x7F, 0x14, 0x7F, 0x14, // 0x23 '#'
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // 0x24 '$'
    0x23, 0x13, 0x08, 0x64, 0x62, // 0x25 '%'
    0x36, 0x49, 0x55, 0x22, 0x50, // 0x26 '&'
    0x00, 0x05, 0x03, 0x00, 0x00, // 0x27 '''
    0x00, 0x1C, 0x22, 0x41, 0x00, // 0x28 '('
    0x00, 0x41, 0x22, 0x1C, 0x00, // 0x29 ')'
    0x14, 0x08, 0x3E, 0x08, 0x14, // 0x2A '*'
    0x08, 0x08, 0x3E, 0x08, 0x08, // 0x2B '+'
    0x00, 0x50, 0x30, 0x00, 0x00, // 0x2C ','
    0x08, 0x08, 0x08, 0x08, 0x08, // 0x2D '-'
    0x00, 0x60, 0x60, 0x00, 0x00, // 0x2E '.'
    0x20, 0x10, 0x08, 0x04, 0x02, // 0x2F '/'
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0x30 '0'
    0x00, 0x42, 0x7F, 0x40, 0x00, // 0x31 '1'
    0x42, 0x61, 0x51, 0x49, 0x46, // 0x32 '2'
    0x21, 0x41, 0x45, 0x4B, 0x31, // 0x33 '3'
    0x18, 0x14, 0x12, 0x7F, 0x10, // 0x34 '4'
    0x27, 0x45, 0x45, 0x45, 0x39, // 0x35 '5'
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 0x36 '6'
    0x01, 0x71, 0x09, 0x05, 0x03, // 0x37 '7'
    0x36, 0x49, 0x49, 0x49, 0x36, // 0x38 '8'
    0x06, 0x49, 0x49, 0x29, 0x1E, // 0x39 '9'
    0x00, 0x36, 0x36, 0x00, 0x00, // 0x3A ':'
    0x00, 0x56, 0x36, 0x00, 0x00, // 0x3B ';'
    0x08, 0x14, 0x22, 0x41, 0x00, // 0x3C '<'
    0x14, 0x14, 0x14, 0x14, 0x14, // 0x3D '='
    0x00, 0x41, 0x22, 0x14, 0x08, // 0x3E '>'
    0x02, 0x01, 0x51, 0x09, 0x06, // 0x3F '?'
    0x32, 0x49, 0x79, 0x41, 0x3E, // 0x40 '@'
    0x7E, 0x11, 0x11, 0x11, 0x7E, // 0x41 'A'
    0x7F, 0x49, 0x49, 0x49, 0x36, // 0x42 'B'
    0x3E, 0x41, 0x41, 0x41, 0x22, // 0x43 'C'
    0x7F, 0x41, 0x41, 0x22, 0x1C, // 0x44 'D'
    0x7F, 0x49, 0x49, 0x49, 0x41, // 0x45 'E'
    0x7F, 0x09, 0x09, 0x09, 0x01, // 0x46 'F'
    0x3E, 0x41, 0x49, 0x49, 0x7A, // 0x47 'G'
    0x7F, 0x08, 0x08, 0x08, 0x7F, // 0x48 'H'
    0x00, 0x41, 0x7F, 0x41, 0x00, // 0x49 'I'
    0x20, 0x40, 0x41, 0x3F, 0x01, // 0x4A 'J'
    0x7F, 0x08, 0x14, 0x22, 0x41, // 0x4B 'K'
    0x7F, 0x40, 0x40, 0x40, 0x40, // 0x4C 'L'
    0x7F, 0x02, 0x0C, 0x02, 0x7F, // 0x4D 'M'
    0x7F, 0x04, 0x08, 0x10, 0x7F, // 0x4E 'N'
    0x3E, 0x41, 0x41, 0x41, 0x3E, // 0x4F 'O'
    0x7F, 0x09, 0x09, 0x09, 0x06, // 0x50 'P'
    0x3E, 0x41, 0x51, 0x21, 0x5E, // 0x51 'Q'
    0x7F, 0x09, 0x19, 0x29, 0x46, // 0x52 'R'
    0x46, 0x49, 0x49, 0x49, 0x31, // 0x53 'S'
    0x01, 0x01, 0x7F, 0x01, 0x01, // 0x54 'T'
    0x3F, 0x40, 0x40, 0x40, 0x3F, // 0x55 'U'
    0x1F, 0x20, 0x40, 0x20, 0x1F, // 0x56 'V'
    0x3F, 0x40, 0x38, 0x40, 0x3F, // 0x57 'W'
    0x63, 0x14, 0x08, 0x14, 0x63, // 0x58 'X'
    0x07, 0x08, 0x70, 0x08, 0x07, // 0x59 'Y'
    0x61, 0x51, 0x49, 0x45, 0x43, // 0x5A 'Z'
    0x00, 0x7F, 0x41, 0x41, 0x00, // 0x5B '['
    0x02, 0x04, 0x08, 0x10, 0x20, // 0x5C '\'
    0x00, 0x41, 0x41, 0x7F, 0x00, // 0x5D ']'
    0x04, 0x02, 0x01, 0x02, 0x04, // 0x5E '^'
    0x40, 0x40, 0x40, 0x40, 0x40, // 0x5F '_'
    0x00, 0x01, 0x02, 0x04, 0x00, // 0x60 '`'
    0x20, 0x54, 0x54, 0x54, 0x78, // 0x61 'a'
    0x7F, 0x48, 0x44, 0x44, 0x38, // 0x62 'b'
    0x38, 0x44, 0x44, 0x44, 0x20, // 0x63 'c'
    0x38, 0x44, 0x44, 0x48, 0x7F, // 0x64 'd'
    0x38, 0x54, 0x54, 0x54, 0x18, // 0x65 'e'
    0x08, 0x7E, 0x09, 0x01, 0x02, // 0x66 'f'
    0x0C, 0x52, 0x52, 0x52, 0x3E, // 0x67 'g'
    0x7F, 0x08, 0x04, 0x04, 0x78, // 0x68 'h'
    0x00, 0x44, 0x7D, 0x40, 0x00, // 0x69 'i'
    0x20, 0x40, 0x44, 0x3D, 0x00, // 0x6A 'j'
    0x7F, 0x10, 0x28, 0x44, 0x00, // 0x6B 'k'
    0x00, 0x41, 0x7F, 0x40, 0x00, // 0x6C 'l'
    0x7C, 0x04, 0x18, 0x04, 0x78, // 0x6D 'm'
    0x7C, 0x08, 0x04, 0x04, 0x78, // 0x6E 'n'
    0x38, 0x44, 0x44, 0x44, 0x38, // 0x6F 'o'
    0x7C, 0x14, 0x14, 0x14, 0x08, // 0x70 'p'
    0x08, 0x14, 0x14, 0x18, 0x7C, // 0x71 'q'
    0x7C, 0x08, 0x04, 0x04, 0x08, // 0x72 'r'
    0x48, 0x54, 0x54, 0x54, 0x20, // 0x73 's'
    0x04, 0x3F, 0x44, 0x40, 0x20, // 0x74 't'
    0x3C, 0x40, 0x40, 0x20, 0x7C, // 0x75 'u'
    0x1C, 0x20, 0x40, 0x20, 0x1C, // 0x76 'v'
    0x3C, 0x40, 0x30, 0x40, 0x3C, // 0x77 'w'
    0x44, 0x28, 0x10, 0x28, 0x44, // 0x78 'x'
    0x0C, 0x50, 0x50, 0x50, 0x3C, // 0x79 'y'
    0x44, 0x64, 0x54, 0x4C, 0x44, // 0x7A 'z'
    0x00, 0x08, 0x36, 0x41, 0x00, // 0x7B '{'
    0x00, 0x00, 0x7F, 0x00, 0x00, // 0x7C '|'
    0x00, 0x41, 0x36, 0x08, 0x00, // 0x7D '}'
    0x08, 0x04, 0x08, 0x10, 0x08, // 0x7E '~'
};

// --- Implementação das Primitivas ---

void gfx_draw_pixel(int16_t x, int16_t y, uint16_t color) {
    // _width e _height são globais de ST7789.c, declarados em ST7789.h
    if((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) return;
    st7789_draw_pixel(x, y, color);
}

void gfx_fill_screen(uint16_t color) {
    st7789_fill_rect(0, 0, _width, _height, color);
}

void gfx_draw_fast_vline(int16_t x, int16_t y, int16_t h, uint16_t color) {
    st7789_fill_rect(x, y, 1, h, color);
}

void gfx_draw_fast_hline(int16_t x, int16_t y, int16_t w, uint16_t color) {
    st7789_fill_rect(x, y, w, 1, color);
}

void gfx_fill_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    st7789_fill_rect(x, y, w, h, color);
}

void gfx_draw_line(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
    // Algoritmo de Linha de Bresenham
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep) {
        _swap_int16_t(x0, y0);
        _swap_int16_t(x1, y1);
    }
    if (x0 > x1) {
        _swap_int16_t(x0, x1);
        _swap_int16_t(y0, y1);
    }

    int16_t dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int16_t err = dx / 2;
    int16_t ystep;

    if (y0 < y1) {
        ystep = 1;
    } else {
        ystep = -1;
    }

    for (; x0 <= x1; x0++) {
        if (steep) {
            gfx_draw_pixel(y0, x0, color);
        } else {
            gfx_draw_pixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
            err += dx;
        }
    }
}

void gfx_draw_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    gfx_draw_fast_hline(x, y, w, color);
    gfx_draw_fast_hline(x, y + h - 1, w, color);
    gfx_draw_fast_vline(x, y, h, color);
    gfx_draw_fast_vline(x + w - 1, y, h, color);
}

void gfx_draw_circle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    // Algoritmo de Círculo de Bresenham
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    gfx_draw_pixel(x0, y0 + r, color);
    gfx_draw_pixel(x0, y0 - r, color);
    gfx_draw_pixel(x0 + r, y0, color);
    gfx_draw_pixel(x0 - r, y0, color);

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        gfx_draw_pixel(x0 + x, y0 + y, color);
        gfx_draw_pixel(x0 - x, y0 + y, color);
        gfx_draw_pixel(x0 + x, y0 - y, color);
        gfx_draw_pixel(x0 - x, y0 - y, color);
        gfx_draw_pixel(x0 + y, y0 + x, color);
        gfx_draw_pixel(x0 - y, y0 + x, color);
        gfx_draw_pixel(x0 + y, y0 - x, color);
        gfx_draw_pixel(x0 - y, y0 - x, color);
    }
}

void gfx_fill_circle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    // Algoritmo de Círculo Otimizado
    gfx_draw_fast_vline(x0, y0 - r, 2 * r + 1, color);
    
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        gfx_draw_fast_vline(x0 + x, y0 - y, 2 * y + 1, color);
        gfx_draw_fast_vline(x0 + y, y0 - x, 2 * x + 1, color);
        gfx_draw_fast_vline(x0 - x, y0 - y, 2 * y + 1, color);
        gfx_draw_fast_vline(x0 - y, y0 - x, 2 * x + 1, color);
    }
}

// --- Funções de Texto ---

void gfx_set_text_color(uint16_t color) {
    text_color = color;
}
void gfx_set_cursor(int16_t x, int16_t y) {
    cursor_x = x;
    cursor_y = y;
}
void gfx_set_text_size(uint8_t size) {
    text_size = (size > 0) ? size : 1;
}

void gfx_draw_char(int16_t x, int16_t y, unsigned char c, uint16_t color, uint8_t size) {
    // Checagem de limite da fonte
    if (c < ' ' || c > '~') {
        c = '?'; // Caractere padrão se fora da faixa
    }
    
    size = (size > 0) ? size : 1;
    
    // Loop de 5 colunas (i)
    for (int8_t i = 0; i < 5; i++) { 
        uint8_t line = glcdfont[(c - ' ') * 5 + i];
        
        // Loop de 8 linhas (j)
        for (int8_t j = 0; j < 8; j++) {
            if (line & 0x1) { // Verifica o bit 0 (pixel de cima)
                if (size == 1) {
                    gfx_draw_pixel(x + i, y + j, color);
                } else {
                    gfx_fill_rect(x + (i * size), y + (j * size), size, size, color);
                }
            }
            line >>= 1; // Move para o próximo bit (pixel de baixo)
        }
    }
}
void gfx_draw_bitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
    // 1. Define a janela de endereço para o tamanho exato do bitmap
    st7789_set_addr_window(x, y, w, h);

    // 2. Calcula o número total de pixels
    // Usar 'long' para evitar overflow em imagens grandes
    long num_pixels = (long)w * (long)h;

    // 3. Prepara para a transferência em massa de dados
    st7789_dc_set(1);     // Modo DADO
    st7789_spi_cs_set(1); // Seleciona o chip

    // 4. Envia todos os pixels de uma vez
    for (long i = 0; i < num_pixels; i++) {
        uint16_t color = bitmap[i];
        
        // Divide a cor 16-bit em dois bytes (Hi e Lo)
        uint8_t hi = (color >> 8) & 0xFF;
        uint8_t lo = color & 0xFF;

        // Envia os bytes na ordem correta (Big Endian)
        st7789_spi_write_byte(hi);
        st7789_spi_write_byte(lo);
    }

    // 5. Libera o barramento SPI
    st7789_spi_cs_set(0); // Desseleciona o chip
}

void gfx_print(const char* str) {
    if (str == 0) return;

    unsigned char c;
    while ((c = *str++)) {
        if (c == '\n') {
            cursor_y += text_size * 8; // Avança linha
            cursor_x = 0;             // Volta ao início
        } else if (c == '\r') {
            // Ignora
        } else {
            // Desenha o caractere
            gfx_draw_char(cursor_x, cursor_y, c, text_color, text_size);
            // Avança o cursor
            cursor_x += text_size * 6; // 5 pixels de largura + 1 de espaço
        }
    }
}